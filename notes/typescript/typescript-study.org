#+TITLE:      typescript学习

* 目录                                                    :TOC_4_gh:noexport:
- [[#基础][基础]]
  - [[#原始数据类型][原始数据类型]]
    - [[#boolean类型][Boolean类型]]
    - [[#number-类型][Number 类型]]
    - [[#string-类型][String 类型]]
    - [[#symbol-类型][Symbol 类型]]
    - [[#array-类型][Array 类型]]
    - [[#空值][空值]]
    - [[#null和undefined][null和undefined]]
  - [[#任意值][任意值]]
    - [[#什么是任意值类型][什么是任意值类型]]
    - [[#任意值的属性和方法][任意值的属性和方法]]
    - [[#未声明类型的变量][未声明类型的变量]]
  - [[#类型推断][类型推断]]
  - [[#联合类型][联合类型]]
    - [[#访问联合属性的属性和方法][访问联合属性的属性和方法]]
  - [[#对象的类型-接口][对象的类型-接口]]
    - [[#什么是接口][什么是接口]]
  - [[#数组的类型][数组的类型]]
    - [[#类型加方括号表示法][类型加方括号表示法]]
    - [[#数组泛型][数组泛型]]
    - [[#用接口表示数组][用接口表示数组]]
    - [[#类数组][类数组]]
    - [[#any-在数组中的应用][any 在数组中的应用]]
  - [[#函数的类型][函数的类型]]
    - [[#函数声明][函数声明]]
    - [[#函数表达式][函数表达式]]
    - [[#用接口定义函数的形状][用接口定义函数的形状]]
    - [[#可选参数][可选参数]]
    - [[#参数默认值][参数默认值]]
    - [[#剩余参数][剩余参数]]
    - [[#重载][重载]]
  - [[#类型断言][类型断言]]
    - [[#类型断言的用途][类型断言的用途]]
      - [[#将一个联合类型断言为其中一个类型][将一个联合类型断言为其中一个类型]]
      - [[#将一个父类断言为更加具体的子类][将一个父类断言为更加具体的子类]]
  - [[#声明文件][声明文件]]
  - [[#内置对象][内置对象]]

* 基础
** 原始数据类型
*** Boolean类型
使用boolean定义布尔值类型：
#+begin_src js
  let isDone: boolean = false
#+end_src
这里需要注意的是使用构造函数Boolean创造的对象不是布尔值，new Boolean 创造的是一个Boolean对象。
*** Number 类型
使用number定义数值类型：
#+begin_src js
  let decLiteral: number = 6;
  let hexLiteral: number = 0xf00d;
  // ES6中的二进制表示法
  let binaryLiteral: number = 0b1010;
  // ES6 中的八进制表示法
  let octalLiteral: number = 0o744;
  let notANumber: number = NaN;
  let infinityNumber: number = Infinity;
#+end_src
*** String 类型
使用string定义字符串类型：
#+begin_src js
  let myName: string = "howell";
  let sentence: string = `hello,my name is ${myName}`;
#+end_src
*** Symbol 类型
#+begin_src js
  const sym = Symbol();
  let obj = {
      [sym]: 'semlinker',
  };
#+end_src
*** Array 类型
#+begin_src js
  let list: number[] = [1,2,3];
  let list: Array<number> = [1,2,3]; // 数组泛型语法
#+end_src
*** 空值
JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：
#+begin_src js
  function warnUser(): void {
      console.log("howell");
  }
#+end_src
*** null和undefined
#+begin_src js
  let u: undefined = undefined;
  let n: null = null;
#+end_src
与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：
#+begin_src js
  // 这样不会报错
  let num: number = undefined;
  // 这样也不会报错
  let u: undefined;
  let num: number = u;
#+end_src

** 任意值
任意值用来表示允许赋值给任意类型
*** 什么是任意值类型
如果是一个普通类型，那么赋值过程中是不允许改变类型的，但是any类型允许被赋值为任意类型：
#+begin_src js
  let myFavoriteNumber: string = 'seven';
  myFavoriteNumber = 7;
  // index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.
  let myFavoriteNumber: any = 'seven';
  myFavoriteNumber = 7;
#+end_src
*** 任意值的属性和方法
在任意值上访问任何属性，调用任何方法都是允许的，可以认为：声明一个变量为任意值后，对它的任何操作，返回内容的类型都是任意值：
#+begin_src js
  let anything: any = 'howell';
  console.log(anything.name);
  anything.setName = 'zing';
#+end_src
*** 未声明类型的变量
变量如果在声明的时候未指定类型，那么它会被识别为任意类型
** 类型推断
如果没有明确的指定类型，那么ts会依照类型推断的规则来为变量定义一个类型。以下代码虽然没有指定类型，但是会在编译的时候报错：
#+begin_src js
  let myFavoriteNumber = 'seven';
  myFavoriteNumber = 7;
  //index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.
#+end_src
值得注意的是，如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成any类型而完全不被类型检查
** 联合类型
联合类型表示取值可以为多种类型中的一种：
#+begin_src js
  let myFavoriteNumber: string | number;
  myFavoriteNumber = 'seven';
  myFavoriteNumber = 7;
#+end_src
联合类型使用 | 分割每个类型。
*** 访问联合属性的属性和方法
当TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性和方法：
#+begin_src js
  function getLength(something: string | number): number {
      return something.length;
  }

  // index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'.
  //   Property 'length' does not exist on type 'number'.
#+end_src
上面例子中，length不是string和number的共有属性，所以会报错。访问共有的属性是没有问题的：
#+begin_src js
  function getString(something: string | number): string {
      return something.toString();
  }
#+end_src
联合类型的变量在被赋值时，会根据类型推论的规则推断出一个类型
** 对象的类型-接口
*** 什么是接口
在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。例如：
#+begin_src js
  interface Person {
      name: string;
      age: number;
  }
  let howell: Person {
      name: "howell",
      age: 25
  }
#+end_src
上面的例子中，我们定义了一个接口 Person，接着定义了一个变量 tom，它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person 一致。关于接口有以下几点注意事项：
1. 接口一般首字母大写
2. 定义的变量不能比接口定义的属性少或者多，赋值的时候，变量的形状必须与接口的形状保持一致
3. 如果希望不完全匹配接口形状，那么可以在接口中用可选属性:
   #+begin_src js
     interface Person{
         name: string;
         age?: number;
     }
   #+end_src
4. 如果希望一个接口允许有任意的属性，那么可以在接口中用任意属性：
   #+begin_src js
     interface Person{
         name: string ;
         age?: number;
         [propName: string]: an y
     }
   #+end_src
5. 如果希望对象中的一些字段只能在创建的时候赋值，那么可以在接口中用只读属性：
   #+begin_src js
     interface Person{
         readonly id: number;
         name: string;
         age?: number;
         [propName: string]: any
     }
   #+end_src

** 数组的类型
*** 类型加方括号表示法
最简单的方法是用类型+方括号来表示数组:
#+begin_src js
  let fibonacci: number[] = [1, 1, 2, 3, 5];
#+end_src
这里有以下几点注意事项：
1. 数组的项中不允许出现其他的类型
2. 数组的方法的参数也会根据数组在定义时约定的类型进行限制
*** 数组泛型
也可以使用数组泛型来表示数组：
#+begin_src js
  let fibonacci: Array<number> = [1, 1, 2, 3, 5];
#+end_src
*** 用接口表示数组
#+begin_src js
  interface NumberArray {
      [index: number]: number;
  }
  let fibonacci: NumberArray = [1, 1, 2, 3, 5];
#+end_src
这里NumberArray表示，只要接口的索引是数字，那么值的类型也必须是数字。虽然接口可以用来描述数组，但实际开发中一般不会这么做。在开发中，一般用它来表示类数组。
*** 类数组
类数组不是数组类型，比如arguments:
#+begin_src js
  const sum = () => {
      let args: {
          [index:number]: number;
          length: number;
          callee: Function;
      } = arguments
  }
#+end_src

*** any 在数组中的应用
用any表示数组中允许出现任意类型：
#+begin_src js
  let list: any[] = ["howell", 23, {friends: "dormey"}];
#+end_src

** 函数的类型
#+BEGIN_QUOTE
函数是JavaScript中的一等公民
#+END_QUOTE
在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）：
*** 函数声明
#+begin_src js
  function sum(x: number, y: number): number {
      return x + y;
  }
#+end_src
这里需要注意：输入多余的（或者少于要求的）参数都是不允许的
*** 函数表达式
#+begin_src js
  let mySum: (x: number, y: number) => number = function (x: number, y: number): number {
      return x + y;
  };
#+end_src
注意不要混淆了TypeScript 中的 => 和ES6中的箭头函数。在TypeScript 中，=>用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。
*** 用接口定义函数的形状
#+begin_src js
  interface AddFunc {
      (x: number, y: number): number;
  }

  let sum: AddFunc;
  sum = function (x: number, y: number) {
      return x + y;
  };
#+end_src
*** 可选参数
与接口中定义可选属性一样，用?表示可选的参数。需要注意：可选参数必须在必须参数后面
*** 参数默认值
TypeScript会将添加了默认值的参数识别为可选参数，但是此时就不受到可选参数必须在必须参数后面的限制了
#+begin_src js
  const sum = function (x: number, y: number = 11) {
      return x + y;
  };
#+end_src
*** 剩余参数
ES6，可以使用...的方式获取函数中的剩余参数：
#+begin_src js
  const sum = function (x: number, ...nums: number[]) {
      nums.forEach((num) => (x += num));
      return x;
  };
#+end_src
这里需要注意一点的是rest参数只能是最后一个参数。
*** 重载
重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。比如我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 'hello' 的时候，输出反转的字符串 'olleh'。利用联合类型，我们可以这么实现：
#+begin_src js
  function reverse(x: number): number;
  function reverse(x: string): string;
  function reverse(x: number | string): number | string {
      if (typeof x === 'number') {
          return Number(x.toString().split('').reverse().join(''));
      } else if (typeof x === 'string') {
          return x.split('').reverse().join('');
      }
  }
#+end_src



** 类型断言
语法： 值 as 类型
*** 类型断言的用途
**** 将一个联合类型断言为其中一个类型
之前提到过，当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型中共有的属性或方法，而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法：
#+begin_src js
  interface Cat {
      name: string;
      run(): void;
  }
  interface Fish {
      name: string;
      swim(): void;
  }

  function isFish(animal: Cat | Fish) {
      if (typeof (animal as Fish).swim === 'function') {
          return true;
      }
      return false;
  }
#+end_src
需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误
**** 将一个父类断言为更加具体的子类
#+begin_src js
  class ApiError extends Error {
      code: number = 0;
  }
  class HttpError extends Error {
      statusCode: number = 200;
  }

  function isApiError(error: Error) {
      if (typeof (error as ApiError).code === 'number') {
          return true;
      }
      return false;
  }
#+end_src
// TODO: not finished
** 声明文件
** 内置对象
