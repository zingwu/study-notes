#+TITLE:      js数据类型

* 目录                                                    :TOC_4_gh:noexport:
- [[#数据类型概念][数据类型概念]]
- [[#数据类型检测][数据类型检测]]
  - [[#typeof][typeof]]
  - [[#instanceof][instanceof]]
  - [[#objectprototypetostring][Object.prototype.toString]]
- [[#数据类型的转换][数据类型的转换]]
  - [[#强制类型转换][强制类型转换]]
    - [[#number-方法的强制转换规则][Number() 方法的强制转换规则]]
    - [[#boolean方法的强制转换规则][Boolean()方法的强制转换规则]]
  - [[#隐式类型转换][隐式类型转换]]
    - [[#的隐式类型转换规则]['=='的隐式类型转换规则]]
    - [[#的隐式类型转换规则-1]['+'的隐式类型转换规则]]

* 数据类型概念
JavaScript数据类型分为基础类型和引用类型，基础类型包括：undefined,Null,String,Boolean,Number,Symbol(ES2015),BigInt(ES2020),引用类型就是Object。引用类型又包括这几种常见的类型：Array - 数组对象、RegExp - 正则对象、Date - 日期对象、Math - 数学函数、Function - 函数对象。

数据类型分为两类在内存中来进行存储：
1. 基础类型存储在栈内存中，被引用或者拷贝时，会在内存中开辟新的空间来创建一个完全相等的变量。
2. 引用类型存储在堆内存中，存储的是其地址，因此在拷贝时，多个引用会指向同一个地址。
* 数据类型检测
** typeof
#+begin_src js
  typeof 1 // 'number'

  typeof '1' // 'string'

  typeof undefined // 'undefined'

  typeof true // 'boolean'

  typeof Symbol() // 'symbol'

  typeof null // 'object'

  typeof [] // 'object'

  typeof {} // 'object'

  typeof console // 'object'

  typeof console.log // 'function'

#+end_src

可以看到，前 6 个都是基础数据类型，而为什么第 6 个 null 的 typeof 是 'object' 呢？这里要和你强调一下，虽然 typeof null 会输出 object，但这只是 JS 存在的一个悠久 Bug，不代表 null 就是引用数据类型，并且 null 本身也不是对象。因此，null 在 typeof 之后返回的是有问题的结果，不能作为判断 null 的方法。如果你需要在 if 语句中判断是否为 null，直接通过 ‘===null’来判断就好。此外还要注意，引用数据类型 Object，用 typeof 来判断的话，除了 function 会判断为 OK 以外，其余都是 'object'，是无法判断出来的。
** instanceof
new 一个对象，那么这个新对象就是它原型链继承上面的对象了，通过 instanceof 我们能判断这个对象是否是之前那个构造函数生成的对象，这样就基本可以判断出这个新对象的数据类型。
#+begin_src js
  let Car = function() {}

  let benz = new Car()

  benz instanceof Car // true

  let car = new String('Mercedes Benz')

  car instanceof String // true

  let str = 'Covid-19'

  str instanceof String // false

#+end_src

instanceof的实现如下：
#+begin_src js
  const myInstanceof = (left, right) => {
      if (typeof left !== "object" || left === null) return false;
      let proto = Object.getPrototypeOf(left);
      while (true) {
          if (proto === null) return false;
          if (proto === right.prototype) return true;
          proto = Object.getPrototypeOf(proto);
      }
  };
#+end_src
以上两种判断数据类型的方法之间的差异：
1. instanceof可以准确的判断复杂的引用数据类型，但是不能正确的判断基础数据类型。
2. typeof可以判断基础数据类型，但是除了function以外的引用数据类型不能判断。
** Object.prototype.toString
toString 是对象的原型方法，调用该方法可以统一返回格式为 [Object xxxx] 的字符串，其中的xxx就是对象的类型。代码如下：
#+begin_src js
  getValueType(value) {
      return Object.prototype.toString.call(value).slice(8, -1);
  }
#+end_src
* 数据类型的转换
** 强制类型转换
*** Number() 方法的强制转换规则
+ 如果是布尔值，true 和 false 分别被转换为 1 和 0；
+ 如果是数字，返回自身；
+ 如果是 null，返回 0；
+ 如果是 undefined，返回 NaN；
+ 如果是字符串，遵循以下规则：如果字符串中只包含数字（或者是 0X / 0x 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 0；如果不是以上格式的字符串，均返回 NaN；
+ 如果是Symbol，抛出错误；
+ 如果是对象，并且部署了 [Symbol.toPrimitive] ，那么调用此方法，否则调用对象的 valueOf() 方法，然后依据前面的规则转换返回的值；如果转换的结果是 NaN ，则调用对象的 toString() 方法，再次依照前面的顺序转换返回对应的值（Object 转换规则会在下面细讲）。

代码如下：
#+begin_src js
  Number(true);        // 1

  Number(false);       // 0

  Number('0111');      //111

  Number(null);        //0

  Number('');          //0

  Number('1a');        //NaN

  Number(-0X11);       //-17

  Number('0X11')       //17
#+end_src

*** Boolean()方法的强制转换规则
这个方法的规则是：除了 undefined、 null、 false、 ''、 0（包括 +0，-0）、 NaN 转换出来是 false，其他都是 true。
其余的 parseInt()、parseFloat()、toString()、String() 这几个方法，之后在整理。
** 隐式类型转换
*** '=='的隐式类型转换规则
+ 如果类型相同，无须进行类型转换；
+ 如果其中一个操作值是 null 或者 undefined，那么另一个操作符必须为 null 或者 undefined，才会返回 true，否则都返回 false；
+ 如果其中一个是 Symbol 类型，那么返回 false；
+ 两个操作值如果都为 string 和 number 类型，那么就会将字符串转换为 number；
+ 如果一个操作值是 boolean，那么转换成 number；
+ 如果一个操作值为 object 且另一方为 string、number 或者 symbol，就会把 object 转为原始类型再进行判断（调用 object 的 valueOf/toString 方法进行转换）。

代码如下：
#+begin_src js
  null == undefined       // true  规则2

  null == 0               // false 规则2

  '' == null              // false 规则2

  '' == 0                 // true  规则4 字符串转隐式转换成Number之后再对比

  '123' == 123            // true  规则4 字符串转隐式转换成Number之后再对比

  0 == false              // true  e规则 布尔型隐式转换成Number之后再对比

  1 == true               // true  e规则 布尔型隐式转换成Number之后再对比

  var a = {
      value: 0,
      valueOf: function() {
          this.value++;
          return this.value;
      }
  };

  // 注意这里a又可以等于1、2、3

  console.log(a == 1 && a == 2 && a ==3);  //true f规则 Object隐式转换
  // 注：但是执行过3遍之后，再重新执行a==3或之前的数字就是false，因为value已经加上去了，这里需要注意一下
#+end_src


*** '+'的隐式类型转换规则
仅当加号两边都是数字时，进行的是加法运算；如果两边都是字符串，则直接拼接，无须进行隐式类型转换。
+ 如果其中有一个是字符串，另外一个是 undefined、null 或布尔型，则调用 toString() 方法进行字符串拼接；如果是纯对象、数组、正则等，则默认调用对象的转换方法会存在优先级（下一讲会专门介绍），然后再进行拼接。
+ 如果其中有一个是数字，另外一个是 undefined、null、布尔型或数字，则会将其转换成数字进行加法运算，对象的情况还是参考上一条规则。
+ 如果其中一个是字符串、一个是数字，则按照字符串规则进行拼接。

代码如下：
#+begin_src js
1 + 2        // 3  常规情况

'1' + '2'    // '12' 常规情况

// 下面看一下特殊情况

'1' + undefined   // "1undefined" 规则1，undefined转换字符串

'1' + null        // "1null" 规则1，null转换字符串

'1' + true        // "1true" 规则1，true转换字符串

'1' + 1n          // '11' 比较特殊字符串和BigInt相加，BigInt转换为字符串

1 + undefined     // NaN  规则2，undefined转换数字相加NaN

1 + null          // 1    规则2，null转换为0

1 + true          // 2    规则2，true转换为1，二者相加为2

1 + 1n            // 错误  不能把BigInt和Number类型直接混合相加

'1' + 3           // '13' 规则3，字符串拼接

#+end_src

