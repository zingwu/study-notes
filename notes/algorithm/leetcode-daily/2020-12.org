#+TITLE:      2020-12

* 目录                                                    :TOC_4_gh:noexport:
- [[#12-21使用最小花费爬楼梯][12-21：使用最小花费爬楼梯]]
  - [[#题目难度][题目难度]]
  - [[#题目描述][题目描述]]
  - [[#示例][示例]]
    - [[#示例1][示例1]]
    - [[#示例2][示例2]]
  - [[#注意][注意]]
  - [[#解法][解法]]
    - [[#解法一动态规划][解法一：动态规划]]
      - [[#思路][思路]]
      - [[#代码][代码]]
      - [[#复杂度分析][复杂度分析]]
    - [[#解法二-优化解法一][解法二： 优化解法一]]
      - [[#思路-1][思路]]
      - [[#代码-1][代码]]
      - [[#复杂度分析-1][复杂度分析]]
- [[#12-22-二叉树的锯齿形层序遍历][12-22: 二叉树的锯齿形层序遍历]]
  - [[#题目难度-1][题目难度]]
  - [[#题目描述-1][题目描述]]
  - [[#示例-1][示例]]
  - [[#解法-1][解法]]
- [[#12-23字符串中的第一个唯一字符][12-23：字符串中的第一个唯一字符]]
  - [[#题目难度-2][题目难度]]
  - [[#题目描述-2][题目描述]]
  - [[#示例-2][示例]]
  - [[#解法-2][解法]]
    - [[#解法一-hash遍历][解法一： hash+遍历]]
      - [[#思路-2][思路]]
      - [[#代码-2][代码]]
      - [[#复杂度分析-2][复杂度分析]]
    - [[#解法二-js字符串方法][解法二： js字符串方法]]
      - [[#思路-3][思路]]
      - [[#代码-3][代码]]
      - [[#复杂度分析-3][复杂度分析]]
- [[#12-24分糖果][12-24：分糖果]]
  - [[#题目难度-3][题目难度]]
  - [[#题目描述-3][题目描述]]
  - [[#示例-3][示例]]
  - [[#解法两次遍历][解法：两次遍历]]
    - [[#思路-4][思路]]
    - [[#代码-4][代码]]
    - [[#复杂度分析-4][复杂度分析]]

* 12-21：使用最小花费爬楼梯
** 题目难度
简单
** 题目描述
数组的每个索引作为一个阶梯，第i个阶梯对应着一个非负数的体力花费值cost[i](索引从0开始)。每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。
** 示例
*** 示例1
+ 输入: cost = [10, 15, 20]
+ 输出: 15
+ 解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。

*** 示例2
+ 输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
+  输出: 6
+ 解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。

** 注意
1. cost 的长度将会在 [2, 1000]。
2. 每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。
** 解法
*** 解法一：动态规划
**** 思路
假设数组的cost的长度为n，则n个阶梯对应的是下标0到n-1，楼层顶部对应下标n，问题等价于计算到达下标n的最小花费，可以通过动态规划的方式求解。
1. 创建长度为n+1 的数组dp，其中dp[i] 表示到达下标i的最小花费。
2. 根据题意，在开始时可以选择从索引为0或1的元素作为初始阶梯，因此有dp[0] = dp[1] = 0。
3. 当2<= i <= n时，可以从下标i-1 使用 cost[i-1] 的花费达到下标[i]，也可以从下标 i-2 使用 cost[i-2] 的花费达到下标 i。为了使总花费最小，dp[i] 应取上述两项的最小值。
因此状态转移方程如下：
#+begin_center
dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])
#+end_center
依次计算dp中每一项的值，最终得到的dp[n] 即为达到楼层顶部的最小花费。
**** 代码
#+begin_src js
  const cost = [10,15,20];
  const minCostClimbingStairs = (cost) => {
      const n = cost.length;
      const dp = new Array(n + 1);
      dp[0] = dp[1] = 0;
      for (let i = 2; i <= n; i++) {
          dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
      }
      return dp[n];
  };
  return minCostClimbingStairs(cost);
#+end_src

#+RESULTS:
: 15

**** 复杂度分析
时间复杂度为O(n)，空间复杂度为O(n)。
*** 解法二： 优化解法一
**** 思路
注意到当 i>=2 时，dp[i] 只和 dp[i−1] 与 dp[i−2] 有关，因此可以使用滚动数组的思想，将空间复杂度优化到 O(1)。
**** 代码
#+begin_src js
  const cost = [10, 15, 20, 10, 20, 30, 1];
  const minCostClimbingStairs = (Cost) => {
      const n = cost.length;
      let prev = 0;
      let curr = 0;
      for (let i = 2; i <= n; i++) {
          let next = Math.min(curr + cost[i - 1], prev + cost[i - 2]);
          prev = curr;
          curr = next;
      }
      return curr;
  };
  return minCostClimbingStairs(cost);
#+end_src

#+RESULTS:
: 46

**** 复杂度分析
时间复杂度为O(n)，空间复杂度为O(1)。

* 12-22: 二叉树的锯齿形层序遍历
** 题目难度
中等
** 题目描述
给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
** 示例
给定二叉树 [3,9,20,null,null,15,7],返回锯齿形层序遍历如下：
#+begin_quote
[
[3],
[20,9],
[15,7]
]
#+end_quote
** 解法
这道题暂时不是很了解，先不记录解法。
#+begin_src js
  const zigzagLevelOrder = (root) => {
      if (!root) {
          return [];
      }

      const ans = [];
      const nodeQueue = [root];

      let isOrderLeft = true;

      while (nodeQueue.length) {
          let levelList = [];
          const size = nodeQueue.length;
          for (let i = 0; i < size; ++i) {
              const node = nodeQueue.shift();
              if (isOrderLeft) {
                  levelList.push(node.val);
              } else {
                  levelList.unshift(node.val);
              }
              if (node.left !== null) {
                  nodeQueue.push(node.left);
              }
              if (node.right !== null) {
                  nodeQueue.push(node.right);
              }
          }
          ans.push(levelList);
          isOrderLeft = !isOrderLeft;
      }

      return ans;
  };
#+end_src

* 12-23：字符串中的第一个唯一字符
** 题目难度
简单
** 题目描述
给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
** 示例
#+begin_quote
s = "leetcode"
返回 0

s = "loveleetcode"
返回 2
#+end_quote
** 解法
*** 解法一： hash+遍历
**** 思路
1. 先遍历一次字符串，用hashmap存储字母-出现次数的键值对
2. 再遍历一次字符串，按照字符串顺序去取得每一个字母出现的次数，找到第一个次数为1 的字母，return
**** 代码
#+begin_src js
  const s = "loveleetcode";
  const firstUniqChar = (s) => {
      const position = new Map();
      for (let i of s) {
          if (position.has(i)) {
              position.set(i, position.get(i) + 1);
          } else {
              position.set(i, 1);
          }
      }
      for (let i = 0; i < s.length; i++) {
          if (position.get(s[i]) === 1) return i;
      }
      return -1;
  };

  return firstUniqChar(s);
#+end_src

#+RESULTS:
: 2

**** 复杂度分析
时间复杂度为O(n)，空间复杂度为O(n)

*** 解法二： js字符串方法
**** 思路
利用字符串的indexOf方法和lastIndexOf方法，如果两次获得的索引相等，则符合题意，return
**** 代码
#+begin_src js
  const s = "loveleetcode";
  const firstUniqChar = (s) => {
      for (let i = 0; i < s.length; i++) {
          if (s.indexOf(s[i]) === s.lastIndexOf(s[i])) {
              return i;
          }
      }
      return -1;
  };

  return firstUniqChar(s);
#+end_src

#+RESULTS:
: 2

**** 复杂度分析
时间复杂度为O(n)，空间复杂度为O(n)

* 12-24：分糖果
** 题目难度
困难
** 题目描述
老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。你需要按照以下要求，帮助老师给这些孩子分发糖果：
1. 每个孩子至少分配到 1 个糖果。
2. 相邻的孩子中，评分高的孩子必须获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？
** 示例
#+begin_quote
输入: [1,0,2]
输出: 5
解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。

输入: [1,2,2]
输出: 4
解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。
第三个孩子只得到 1 颗糖果，这已满足上述两个条件。
#+end_quote
** 解法：两次遍历
*** 思路
我们可以将「相邻的孩子中，评分高的孩子必须获得更多的糖果」这句话拆分为两个规则，分别处理。
1. 左规则：当 ratings[i−1]<ratings[i] 时，i 号学生的糖果数量将比 i−1 号孩子的糖果数量多。
2. 右规则：当 ratings[i]>ratings[i+1] 时，i 号学生的糖果数量将比 i+1 号孩子的糖果数量多。
遍历该数组两次，处理出每一个学生分别满足左规则或右规则时，最少需要被分得的糖果数量。每个人最终分得的糖果数量即为这两个数量的最大值。
*** 代码
#+begin_src js
  const ratings = [1, 0, 2];
  const candy = (ratings) => {
      const n = ratings.length;
      const left = Array(n).fill(1);
      for (let i = 0; i < n; i++) {
          if (i > 0 && ratings[i] > ratings[i - 1]) {
              left[i] = left[i - 1] + 1;
          } else {
              left[i] = 1;
          }
      }
      let right = 0,
          result = 0;
      for (let i = n - 1; i >= 0; i--) {
          if (i < n - 1 && ratings[i] > ratings[i + 1]) {
              right++;
          } else {
              right = 1;
          }
          result += Math.max(left[i], right);
      }
      return result;
  };
  return candy(ratings);
#+end_src

#+RESULTS:
: 5

*** 复杂度分析
时间复杂度为O(n)，空间复杂度为O(n)

